# 전반 설계

## 아키텍쳐
* MSA 아키텍쳐를 선택하였습니다.
* MSA를 선택한 이유는 다음과 같습니다.
* 1. 장애처리가 가능해진다. 이에 따라 서비스가 유연하다.
* 2. 마이크로서비스별 독립적인 운영이 가능해진다.
* 3. 한 화면에 종속된 api보다는 다양한 api를 서버에서 제공하고, 화면에서는 필요한 api들을 호출하여 사용하는 방식이 가능해진다. 이에 따라 화면에 종속적이지 않은 유연한 api 구성이 가능해진다.

## 도메인 모델 패턴
* 도메인 모델 패턴을 사용해서, 객체지향적으로 비즈니스 로직을 도메인에서 관리한다.
* service 계층은 도메인 모델에서 비즈니스 로직을 호출하는 방식으로 하며, 트랜잭션 계층으로만 사용한다.
* 이를 통해 후술할 선언형 프로그래밍을 더욱 적극적으로 사용할 수 있다.
* 테스트 코드에서 service 계층만 테스트 하지 않고, 도메인 계층도 테스트한다.

## MVC 계층분리
* MVC 계층은 철저히 분리한다.
* repository 계층은 엔티티와 dto 직접조회가 필요한 경우 dto를 사용하는 것이 가능하다.
* service 계층은 트랜잭션 계층으로 도메인 계층을 호출하여 트랜잭션을 관리한다.
* 이 계층에서는 dto와 엔티티의 사용이 모두 가능하며, controller 계층에는 반드시 dto만을 전달한다.
* controller에 전달할 객체를 완벽하게 만들어서 전달하여, osiv를 off 할 수 있도록 한다.
* controller 계층은 오로지 dto만을 사용한다.

## 선언형 프로그래밍
* 기본적인 방식은 선언형 프로그래밍이다.
* 대부분의 코드 방식은 함수를 호출하여 표현을 선언하는 선언형 프로그래밍을 따르도록 한다.
* 특히나 mvc 계층에는 더욱이 강하게 적용한다.

## validator
* validator는 선언형 프로그래밍의 방식에 따라 custom exception을 throw 하는 방식으로 설계하여
* validator로 부터 값을 리턴받아서 재 판별하는 작업을 하지 않는다.

## validator 계층 분리
* validator는 계층을 분리한다.
* 일반적으로 service 계층 전용 validator와 controller 계층 전용 validator로 나눈다.
* validator는 범용적인 방식보다는, 나가는 쿼리를 줄이고, 성능을 향상할 수 있도록 함수에 종속되게 설계한다.

## osiv
* 컨트롤러까지 영속성을 물고 늘어지는 osiv는 off한다.
* 이를 통해 장애를 미리 방지 할 수 있다.

## CQS
* 서비스 계층의 경우, 커맨드와 쿼리는 분리한다.
* 이는 확장성과 유지보수성을 고려한 설계 때문이다.
* 커맨스의 경우 리턴값이 존재하여서는 안되지만,
* 예외적으로 insert를 하는 save함수들은 필요시 id나 식별자를 리턴하는 것이 가능하도록 한다.
* 이유는 테스트코드 때문이다.

## 데이터 조회
### 단건 데이터 조회
* 단건은 엔티티 그대로 조회하고
* 서비스 계층에서 controller 계층으로 옮길때에는
* Mapper를 사용해서 매핑하여 dto의 형태로 리턴한다.
### 대량의 데이터 조회(컬렉션 조회)
* 대량의 데이터를 조회할 때에는 dto projection을 사용한다.
* 매퍼를 사용하지 않고, 바로 dto로 값을 조회한다.
* 이를 통해 조회 성능을 향상시킬 수 있다.

## 성능 향상은 범용적인 것 위주로 하라
* 성능 향상은 성능을 더욱 많이 올릴 수 있는 것들 위주로 한다.
* 특히나 성능 이슈는 대부분 조회에서 발생하며,
* 더욱이 대량의 데이터를 조회하는 경우 발생한다.
* 대량의 데이터 조회의 경우에는 dto projection, 인덱스 등 성능을 끌어올릴 수 있는 최대로 성능을 끌어올린다.
* 이에 대한 설명은 [스타일가이드](https://github.com/liveforone/study/tree/main/%5B%EB%82%98%EB%A7%8C%EC%9D%98%20%EC%8A%A4%ED%83%80%EC%9D%BC%20%EA%B0%80%EC%9D%B4%EB%93%9C%5D)에도 잘 나타나 있다.

## 쿼리 메서드
* validator에서 엔티티가 아닌 식별자가 필요할 경우에는 식별자만을 꺼내어준다.
* 쿼리는 반드시 필요한 것들만 조회하여 사용한다.
* 검색 쿼리를 반드시 like%를 이용하여 인덱스를 탈 수 있도록 한다.
* 리파지토리 유틸클래스를 이용해 복잡한 리파지토리를 깔끔하게 유지한다.
* Q클래스 중복의 경우에는 링크를 참조하라.
* 하나의 쿼리로 여러 조건을 처리할 수 있는 동적쿼리를 적극활용해 최대한 적은 함수를 유지할 수 있도록 한다.

## 파라미터 디폴트 값 설정
* 파라미터는 디폴트 값을 설정한다.
* 문자 혹은 숫자 타입의 모든 값에 디폴트 값을 적용한다.

## provide API 
* 프로젝트 내에 다른 마이크로 서비스에 제공하는 api는 /provide로 시작하게 네이밍한다.
* 자사의 타 프로젝트에서도 사용가능하도록 한다.

## enum 문자열로 변환하여 저장
* [enum 저장 이슈](https://github.com/liveforone/intelligent_taxi/blob/master/Documents/JPA_ENUM_ISSUE.md)에서도 볼 수 있듯이 
* enum을 저장할땐 안전하게 문자열로 변환하여 저장하도록 한다.